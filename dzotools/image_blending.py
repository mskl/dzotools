# AUTOGENERATED! DO NOT EDIT! File to edit: 05_image_blending.ipynb (unless otherwise specified).

__all__ = ['WrappedNdArray', 'laplace_op', 'prepare_target', 'show_blending_parts', 'gauss_seidel']

# Cell
import numpy as np

# Cell
class WrappedNdArray:
    """Wraps an ndarray and only returns value if within bounds."""
    def __init__(self, array: np.ndarray):
        self.array = array

    def is_inside(self, location):
        return all([
            0 <= location[0] < self.array.shape[0],
            0 <= location[1] < self.array.shape[1],
        ])

    def __getitem__(self, location):
        if self.is_inside(location):
            return self.array[location]
        return 0

    def __setitem__(self, location, value):
        if self.is_inside(location):
            self.array[location] = value

# Cell
def laplace_op(y: int, x: int, arr: np.array) -> float:
    """Calculate the discrete Laplace operator on arr"""
    return -4 * arr[y, x] + arr[y+1, x] + arr[y-1, x] + arr[y, x+1] + arr[y, x-1]

# Cell
def prepare_target(bg: np.array, fg: np.array, msk: np.array) -> np.array:
    """Calculate the vector b used for Gauss-Seidel computation."""
    b = np.zeros_like(bg, dtype="float32")

    _fg = WrappedNdArray(fg)
    _bg = WrappedNdArray(bg)

    heigth, width = msk.shape
    for y in range(heigth):
        for x in range(width):
            if msk[y, x] == 1:
                b[y, x] = laplace_op(y, x, _fg)
            else:
                b[y, x] = laplace_op(y, x, _bg)
    return b

# Cell
def show_blending_parts(bg: np.array, fg: np.array, msk: np.array):
    """Visualize the background, foreground and a resulting 'hard' masked image without blending."""
    masked = np.where(msk[...,None], fg, bg)
    fig, ax = plt.subplots(ncols=4, figsize=(12, 4), sharey=True)
    ax[0].imshow(bg, vmin=0, vmax=1)
    ax[0].set_title("background")
    ax[1].imshow(fg, vmin=0, vmax=1)
    ax[1].set_title("foreground")
    ax[2].imshow(msk, vmin=0, vmax=1, cmap='gray')
    ax[2].set_title("mask")
    ax[3].imshow(masked, vmin=0, vmax=1)
    ax[3].set_title("hard-masked")
    plt.tight_layout()
    plt.show()

# Cell
def gauss_seidel(
    bg: np.array,
    fg: np.array,
    msk: np.array,
    iteration_steps: int = 91,
    checkpoint_steps: int = 10,
) -> dict:
    """Perform gauss-sedel blending on the image.
    Store the results in a dictionary once in checkpoint_steps.
    Output starts as a background for faster convergence.
    Only iterate over masked values to speed up processing.
    """

    b = prepare_target(bg, fg, msk)
    masked_indexes = np.where(msk > 0.5)
    current = WrappedNdArray(bg.copy())

    results = {}
    for step in trange(iteration_steps):
        updated = current.array.copy()
        if step % checkpoint_steps == 0:
            results[step] = updated.copy()

        for y, x in zip(*masked_indexes):
            around = sum([
                current[y-1, x],
                current[y+1, x],
                current[y, x-1],
                current[y, x+1]
            ])
            updated[y, x] = 0.25 * (around - b[y, x])

        current.array = np.clip(updated, 0, 1).copy()

    return results