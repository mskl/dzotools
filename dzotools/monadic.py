# AUTOGENERATED! DO NOT EDIT! File to edit: 01_monadic.ipynb (unless otherwise specified).

__all__ = ['imgload', 'arr2img', 'clipvals', 'brightness', 'contrast', 'plot_hist', 'plot_cdf', 'equalize']

# Cell
from PIL import Image
import numpy as np
from collections import Counter
import matplotlib.pyplot as plt

# Cell
def imgload(path: str = "data/lenna.png", convert: str = None) -> np.array:
    """Load the image at given path and convert it to numpy ndarray."""
    img = Image.open(path)

    if convert:
        img = img.convert(convert)

    return np.asarray(img, dtype="int32")

# Cell
def arr2img(arr: np.array) -> Image:
    """Convert the PIL.Image to numpy array."""
    return Image.fromarray(arr.astype("uint8"))

# Cell
def clipvals(arr: np.array) -> np.array:
    """Clip the values to ve within the range of 1 byte."""
    # Equivalent to np.minimum(a_max, np.maximum(a, a_min))
    return np.clip(arr, 0, 255)

# Cell
def brightness(arr: np.array, adjust: int) -> Image:
    arr = clipvals(arr + adjust)
    return arr2img(arr)

# Cell
def contrast(arr: np.array, adjust: float) -> Image:
    # Equivalent to np.minimum(a_max, np.maximum(a, a_min))
    arr =  clipvals(arr * adjust)
    return arr2img(arr)

# Cell
def plot_hist(arr: np.array):
    """Plot histogram over pixel intensities."""
    ctr = Counter(arr.flatten())
    histdict = {k: ctr[k] for k in range(256)}

    fig, ax = plt.subplots()
    ax.bar(histdict.keys(), histdict.values())
    ax.set_xlabel("pixel value")
    ax.set_ylabel("value count")
    ax.set_title("Histogram (pixel brightness frequencies)")
    plt.tight_layout()
    return fig, ax

# Cell
def plot_cdf(arr: np.array):
    """Plot cumulative dictribution function over pixel intensities."""
    nctr = Counter(arr.flatten())
    ndict = dict(sorted(nctr.items(), key=lambda x: x[0]))
    cdict = dict(zip(ndict.keys(), np.cumsum(list(ndict.values()))))

    fig, ax = plt.subplots()
    ax.plot(cdict.keys(), cdict.values())
    ax.set_title("CDF (cumulative densities of pixel brightness values)")
    plt.tight_layout()
    return fig, ax

# Cell
def equalize(arr: np.array) -> np.array:
    """Change the input array by equalizing the histogram.
    This is applied on all pixels so be advised when called on RGB input.
    """

    # Count the values
    ctr = Counter(arr.flatten())
    # Sort the histogram dictionary
    histdict = dict(sorted(ctr.items(), key=lambda x: x[0]))
    # Create a second dict with cdf
    cumdict = dict(zip(histdict.keys(), np.cumsum(list(histdict.values()))))

    cmin = list(cumdict.values())[0]
    cmax = list(cumdict.values())[-1]

    # Normalize and count the values
    normvals = ((np.array([*cumdict.values()]) - cmin) / (cmax - cmin))
    normalised = np.round(normvals * 255).astype("int")

    # Apply the dictionary by vectorizing
    normdict = dict(zip(cumdict.keys(), normalised))
    return np.vectorize(normdict.get)(arr)